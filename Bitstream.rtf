{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red0\green0\blue120;}
\margl1440\margr1440\vieww24540\viewh16020\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 \expnd0\expndtw0\kerning0
Three kinds of data -\
1) Signed integer\
2) 64-bit floating point\
3) Character string\
\
Lead byte:\
Bit0..1\
	00 signed integer\
		bit2=0 short value in bit3..7 (-16..15) [bit 3 is the sign bit]\
		bit2=1 long value, number of bytes to follow (-1) in bit5..bit7 (1..8), MSB-first, sign extended from first byte [bit 0 of the first byte is the sign bit]\
	01 floating-point\
		bit2=0 floats [32-bit], number of floating-point values to follow (-1) in bit3..7 (1..32), MSB-first\
		bit2=1 doubles [64-bit], number of floating-point values to follow (-1) in bit3..bit7 (1..32), MSB-first\
	10 string\
		bit2=0 length in bit3..7 (0..31) not NULL-terminated\
		bit2=1 number of bytes for length (-1) in bit5..7 (1..8)\
	11 number of values following\
		bit2=0 number of values in bit3..7 (0..31) => EOM = zero values follow (0xC0)\
		bit2=1 number of bytes for number of values (-1) in bit5..7 (1..8)\
\
Examples -\
EOM is 11000000 (0xC0)\
0 is 00000000 (0x00)\
13 is 00001101(0x0D)\
-13 is 00010011(0x13)\
144 is 00010001(0x11)+00000000(0x00)+10010000(0x90)\
-144 is 00110000(0x31)+11111111(0xFF)+01110000(0x70)\
1.23 2.34 4.56 is 01100010(0x62)+b(1.23)+b(2.34)+b(4.56), if b(x) is the binary representation of x\
"" is 10000000 (0x80)\
"abc" is 10000011(0x83)+'a'+'b'+'c'\
"abcde abcde abcde abcde abcde abcde " is 10100001(0xA1)+00100100(0x24)+'a'+'b'+'c'+...+'e'+' '\
\
As a complete example, "13 144 1.23 2.45 abc" is 11000100(0xC5)+(0x0D)+(0x00,0x90)+(0x61,b(1.23),b(2.45))+(0x83,'a','b','c')+EOM => 10 + 3 x sizeof(floating-point) [21 bytes as ASCII, including NULL]; with floats, this would be 22 bytes versus 21 bytes and, with doubles, this would be 34 bytes versus 21 bytes. However, the precision of the values using this format is far greater than the representation as ASCII, and the ASCII representation does not include the number of 'slots' to follow.\
\
Note that the '11xxxxxx' acts as SOM and can be used to reserve 'slots' for the values that follow; although floating-point values have their own 'counter', each is counted in the total.\
That is, if three floating-point values appear in sequence, only one prefix byte is needed, to indicate that there are three floating-point values next in the stream but, at the same time, the three floating-point values account for three 'slots' in the count stored in the SOM.\
\
This uses one byte for EOM, one byte for values in the range -16..15, two bytes for values in the range -128..127, three bytes for values in the range -32,768..32,767, four bytes for values in the range -16,777,216..16,777,215, five bytes for values in the range -4,294,967,296..4,292,967,295, et cetera.\
Double values take (1+8*n) bytes, float values take (1+4*n) bytes, strings under 31 bytes in length take n+1 bytes (lead byte. n bytes), strings over 31 bytes in length but less than 256 bytes take n+2 bytes (lead byte, length byte, n bytes), strings over 255 bytes in length but less than 65536 bytes take n+3 bytes (lead byte, two length bytes, n bytes), et cetera.\
\
A single double is 12.5% longer, two doubles are 6.25% longer, three doubles are 4.2% longer, et cetera; a single float is 25% longer, two floats are 12.5% longer, three floats are 8.3% longer, et cetera.\
4-byte longs use between 1 and 5 bytes, so either 75% reduction, 50% reduction, 25% reduction, no difference or 25% increase in length, short strings are the same length, medium strings are 3% longer, long strings are 0.7% longer, et cetera, assuming that the NULL is considered as part of the string.\
}