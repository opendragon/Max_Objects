% File: maxboxmacros.mp

% Define colours that we need:
color yellow;
yellow = red + green;

% Define gap between inner box and outer box:
numeric bandThick;
bandThick := 4;

pair bandInside, bandHollow;
bandInside := (0, bandThick);
bandHollow := (0.5bandThick, 0);

% Define spacing and gaps around pins:
numeric bspace, dspace, poffset, cspace, lwidth, wslop;
bspace := 2;
dspace := 4;
pspace := 20;
poffset := 6;
cspace := 1.5;
lwidth := 0.8;
wslop := 10;

pair corr;
pair ci[][];
pair co[][];

% Define the macros:
%% Derived from boxes.mp, adding minimum size arguments.
vardef boxitmin@#(text tt)(expr wide, high) =
  save tb, lr;
  numeric tb, lr;
  beginbox_("boxpath_","sizebox_",@#,tt);
  generic_declare(pair) _n.sw, _n.s, _n.se, _n.e, _n.ne, _n.n, _n.nw, _n.w;
  0 = xpart (@#nw-@#sw) = ypart(@#se-@#sw);
  0 = xpart(@#ne-@#se) = ypart(@#ne-@#nw);
  @#w = .5[@#nw,@#sw];
  @#s = .5[@#sw,@#se];
  @#e = .5[@#ne,@#se];
  @#n = .5[@#ne,@#nw];
  tb := ypart(urcorner pic_@# - llcorner pic_@#);
  if (tb < high):
    tb := high;
  fi
  lr := xpart(urcorner pic_@# - llcorner pic_@#);
  if (lr < wide):
    lr := wide;
  fi
  @#ne-@#c = @#c-@#sw = (@#dx,@#dy) + 0.5*(lr,tb);
  endbox_(clearb_,@#);
enddef;

vardef qic_mac_ suffix $ =
  fixsize($); fixpos($);
  save noff;
  pair noff;
  noff := (xpart($sw-(corr+llcorner pic_$))+$dx, ypart($off));
  pic_$ shifted noff
enddef;

vardef pic suffix $ = qic_mac_ $ enddef;

def drawboxedm(text tt) =         % Draw each box
  fixsize(tt); fixpos(tt);
  forsuffixes ss=tt: draw qic_mac_.ss; draw bpath.ss; endfor
enddef;

def drawunboxedm(text tt) =       % Draw contents of each box
  fixsize(tt); fixpos(tt);
  forsuffixes ss=tt: draw qic_mac_.ss; endfor
enddef;

def create_inside_box(expr pp, nin, nout) =
  begingroup
	% Create the text box:
	numeric np, wid;
	if nin > nout:
	  np := nin;
	else:
	  np := nout;
	fi
	wid := dspace*(2*np + 0.75*(np-1)) + wslop;
    boxitmin.obj(pp)(wid, 0);
    obj.dx = 0;
    obj.dy = bspace;
    boxit.sur();
    sur.nw = obj.nw + bandInside;
    sur.ne = obj.ne + bandInside;
    sur.sw = obj.sw - bandInside;
    sur.se = obj.se - bandInside;
    
	% Create inlets:
	for ii = 1 upto nin:
	  circleit.in[ii](qn[ii]);
	  in[ii].dx = in[ii].dy = cspace;
	endfor;
	pair deli;
	for ii = 1 upto (nin - 1):
	   in[ii + 1].c - in[ii].c = deli;
	endfor;
	if nin > 0:
	  in[1].s = sur.nw + (dspace, pspace);
	fi
	if nin > 1:
	  in[nin].s = sur.ne + (-dspace, pspace);
	fi
	
	% Create outlets:
	for ii = 1 upto nout:
	  circleit.out[ii](qn[ii]);
	  out[ii].dx = out[ii].dy = cspace;
	endfor;
	pair delo;
	for ii = 1 upto (nout - 1):
	  out[ii + 1].c - out[ii].c = delo;
	endfor;
	if nout > 0:
	  out[1].n = sur.sw + (dspace, -pspace);
	fi
	if nout > 1:
	  out[nout].n = sur.se + (-dspace, -pspace);
	fi
	
	% Render the boxes:
	fill bpath sur withcolor yellow;
	drawboxed(sur);
	unfill bpath obj;
	corr := (0,0);
	drawboxedm(obj);
	
	% Draw the inlets and outlets:
	pickup pencircle scaled 0.5pt;
	for ii = 1 upto nin:
	  drawboxed(in[ii]);
	endfor;
	for ii = 1 upto nout:
	  drawboxed(out[ii]);
	endfor;
	pickup defaultpen;

	% Draw inlet and outlet pins:
	path hi;
	numeric le, re, lc, rc, te, th, be, bh;
	   
	for ii = 1 upto nin:
	  le := xpart in[ii].c - dspace;
	  re := xpart in[ii].c + dspace;
	  lc := xpart in[ii].c - lwidth;
	  rc := xpart in[ii].c + lwidth;
	  te := ypart in[ii].c - poffset;
	  th := ypart sur.n;
	  hi := (le, ypart obj.n) -- (re, ypart obj.n) -- (re, th) -- (rc, th) --
	              (rc, te) -- (lc, te) -- (lc, th) -- (le, th) -- cycle;
	  fill hi withcolor black;
	  draw hi;
	endfor;
	for ii = 1 upto nout:
	  le := xpart out[ii].c - dspace;
	  re := xpart out[ii].c + dspace;
	  lc := xpart out[ii].c - lwidth;
	  rc := xpart out[ii].c + lwidth;
	  be := ypart out[ii].c + poffset;
	  bh := ypart sur.s;
	  hi := (le, ypart obj.s) -- (re, ypart obj.s) -- (re, bh) -- (rc, bh) --
	              (rc, be) -- (lc, be) -- (lc, bh) -- (le, bh) -- cycle;
	  fill hi withcolor black;
	  draw hi;
	endfor;
  endgroup
enddef;

def create_inside_box_no_pins(expr ll, name, nin, nout, tag) =
  begingroup
	numeric np, wid;
	if nin > nout:
	  np := nin;
	else:
	  np := nout;
	fi
	wid := dspace*(2*np + 0.75*(np-1)) + wslop;
    boxitmin.obj[tag](name)(wid, 0);
    obj[tag].dx = 0;
    obj[tag].dy = bspace;
    boxit.sur[tag]();
    sur[tag].nw = obj[tag].nw + bandInside;
    sur[tag].ne = obj[tag].ne + bandInside;
    sur[tag].sw = obj[tag].sw - bandInside;
    sur[tag].se = obj[tag].se - bandInside;
    sur[tag].sw = ll;
    
	% Create inlets:
	pair deli;
	for ii = 1 upto (nin - 1):
	  ci[tag][ii + 1] - ci[tag][ii] = deli;
	endfor;
	if nin > 0:
	  ci[tag][1] = sur[tag].nw + (dspace, -0.5bandThick);
	fi
	if nin > 1:
	  ci[tag][nin] = sur[tag].ne + (-dspace, -0.5bandThick);
	fi
	
	% Create outlets:
	pair delo;
	for ii = 1 upto (nout - 1):
	  co[tag][ii + 1] - co[tag][ii] = delo;
	endfor;
	if nout > 0:
	  co[tag][1] = sur[tag].sw + (dspace, 0.5bandThick);
	fi
	if nout > 1:
	  co[tag][nout] = sur[tag].se + (-dspace, 0.5bandThick);
	fi
	
	% Render the boxes:
	fill bpath sur[tag] withcolor yellow;
	drawboxed(sur[tag]);
	unfill bpath obj[tag];
	corr := (0,0);
	drawboxedm(obj[tag]);
	
	% Draw inlet and outlet pins:
	path hi;
	numeric le, re, th, bh;
	   
	for ii = 1 upto nin:
	  le := xpart ci[tag][ii] - dspace;
	  re := xpart ci[tag][ii] + dspace;
	  th := ypart sur[tag].n;
	  hi := (le, ypart obj[tag].n) -- (re, ypart obj[tag].n) -- (re, th) -- (le, th) -- cycle;
	  fill hi withcolor black;
	  draw hi;
	endfor;
	for ii = 1 upto nout:
	  le := xpart co[tag][ii] - dspace;
	  re := xpart co[tag][ii] + dspace;
	  bh := ypart sur[tag].s;
	  hi := (le, ypart obj[tag].s) -- (re, ypart obj[tag].s) -- (re, bh) -- (le, bh) -- cycle;
	  fill hi withcolor black;
	  draw hi;
	endfor;
  endgroup
enddef;

def create_hollow_box(expr ll, name, nin, nout, tag) =
  begingroup
	% Create the text box:
	numeric np, wid;
	if nin > nout:
	  np := nin;
	else:
	  np := nout;
	fi
	wid := dspace*(2*np + 0.75*(np-1)) + wslop;
    boxitmin.obj[tag](name)(wid, 0);
    obj[tag].dx = 0;
    obj[tag].dy = bspace;
    boxit.sur[tag]();
    sur[tag].nw = obj[tag].nw + bandInside - bandHollow;
    sur[tag].ne = obj[tag].ne + bandInside + bandHollow;
    sur[tag].sw = obj[tag].sw - (bandInside + bandHollow);
    sur[tag].se = obj[tag].se + bandHollow - bandInside;
    sur[tag].sw = ll;
    
	% Create inlets:
	pair deli;
	for ii = 1 upto (nin - 1):
	  ci[tag][ii + 1] - ci[tag][ii] = deli;
	endfor;
	if nin > 0:
	  ci[tag][1] = sur[tag].nw + (dspace, -0.5bandThick);
	fi
	if nin > 1:
	  ci[tag][nin] = sur[tag].ne + (-dspace, -0.5bandThick);
	fi
	
	% Create outlets:
	pair delo;
	for ii = 1 upto (nout - 1):
	  co[tag][ii + 1] - co[tag][ii] = delo;
	endfor;
	if nout > 0:
	  co[tag][1] = sur[tag].sw + (dspace, 0.5bandThick);
	fi
	if nout > 1:
	  co[tag][nout] = sur[tag].se + (-dspace, 0.5bandThick);
	fi
	
	% Render the boxes:
	drawboxed(sur[tag]);
	unfill bpath obj[tag];
	corr := bandHollow;
	drawunboxedm(obj[tag]);
	
	% Draw inlet and outlet pins:
	path hi;
	numeric le, re, th, bh;
	   
	for ii = 1 upto nin:
	  le := xpart ci[tag][ii] - dspace;
	  re := xpart ci[tag][ii] + dspace;
	  th := ypart sur[tag].n;
	  hi := (le, ypart obj[tag].n) -- (re, ypart obj[tag].n) -- (re, th) -- (le, th) -- cycle;
	  fill hi withcolor black;
	  draw hi;
	endfor;
	for ii = 1 upto nout:
	  le := xpart co[tag][ii] - dspace;
	  re := xpart co[tag][ii] + dspace;
	  bh := ypart sur[tag].s;
	  hi := (le, ypart obj[tag].s) -- (re, ypart obj[tag].s) -- (re, bh) -- (le, bh) -- cycle;
	  fill hi withcolor black;
	  draw hi;
	endfor;
  endgroup
enddef;

def drawboxedc(text tt, cc) =         % Draw each box
  fixsize(tt); fixpos(tt);
  forsuffixes ss=tt: draw pic_mac_.ss withcolor cc; draw bpath.ss; endfor
enddef;

vardef drawshadowed(text tt) =
  color cc;
  fixsize(tt);
  forsuffixes ss = tt:
  	fill bpath.ss shifted (1,-1);
  	unfill bpath.ss;
  	cc := black;
  	if ss.col = 1:
  	  cc := red;
  	fi
  	if ss.col = 2:
  	  cc := green;
  	fi
  	if ss.col = 3:
  	  cc := blue;
  	fi
  	drawboxedc(ss)(cc);
  endfor
enddef;

vardef cuta(suffix aa,bb) expr pp =
  drawarrow pp cutbefore bpath.aa cutafter bpath.bb;
  point 0.5*length pp of pp
enddef;

vardef self@# expr pp =
  cuta(@#,@#) @#.c{curl0}..@#.c+pp..{curl0}@#.c
enddef;

% $Log: maxboxmacros.mp,v $
% Revision 1.4  2006/07/20 04:47:53  churchoflambda
% Re-added the files to record their changes.
%
% Revision 1.2  2005/08/02 15:07:09  churchoflambda
% Added CVS tags; add rail diagrams for pfsm, map1d, map2d, map3d and listen.
%

